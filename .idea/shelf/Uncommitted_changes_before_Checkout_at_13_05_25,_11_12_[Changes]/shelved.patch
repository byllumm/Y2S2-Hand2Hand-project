Index: hand2hand/lib/supabase_service.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'package:hand2hand/chatpreview.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\nimport 'dart:io';\nimport 'package:hand2hand/message.dart';\n\nclass SupabaseService {\n  // Singleton implementation\n  SupabaseService._privateConstructor();\n  static final SupabaseService _instance =\n      SupabaseService._privateConstructor();\n  factory SupabaseService() => _instance;\n\n  final _client = Supabase.instance.client;\n  String? _loggedInUsername; // Store the logged-in username\n  int? _userId; // Cache the logged-in user's ID\n  RealtimeChannel? _messageChannel;\n\n  // Stream items from the Supabase database for the logged-in user\n  Stream<List<Map<String, dynamic>>> streamItems() {\n    if (_userId == null) {\n      throw Exception('User is not logged in or user ID not available');\n    }\n\n    return _client\n        .from('items')\n        .stream(primaryKey: ['id'])\n        .eq('user_id', _userId!)\n        .map((data) => List<Map<String, dynamic>>.from(data));\n  }\n\n  Stream<List<Map<String, dynamic>>> streamOtherUsersItems() {\n    if (_userId == null) {\n      throw Exception('User is not logged in');\n    }\n\n    return _client\n        .from('items')\n        .stream(primaryKey: ['id'])\n        .neq('user_id', _userId!)\n        .map((data) => List<Map<String, dynamic>>.from(data));\n  }\n\n  Future<Map<String, dynamic>> getItemStatus(int itemId) async {\n  final response = await _client\n      .from('items')\n      .select('is_requested, is_deleted, user_id')\n      .eq('id', itemId)\n      .maybeSingle();\n\n  if (response != null) {\n    return {\n      'available': !response['is_requested'] && !response['is_deleted'],\n      'is_requested': response['is_requested'],\n      'is_deleted': response['is_deleted'],\n      'user_id': response['user_id'],\n    };\n  }\n  return {'available': false};\n}\n\n  // Request an item (mark it as requested)\n  Future<bool> requestItem(int itemId) async {\n  try {\n    final currentUserId = _userId;\n    if (currentUserId == null) {\n      throw Exception('User not logged in');\n    }\n\n    final response = await _client\n        .from('items')\n        .update({\n          'is_requested': true,\n          'requested_by': currentUserId, // Track who requested it\n          'requested_at': DateTime.now().toIso8601String(),\n        })\n        .eq('id', itemId)\n        .select();\n\n    return response.isNotEmpty;\n  } catch (e) {\n    print('Error requesting item: $e');\n    return false;\n  }\n}\n\n  Future<Map<String, dynamic>?> getUserById(int userId) async {\n  final response = await _client\n      .from('User')\n      .select('id, name, username, location')\n      .eq('id', userId)\n      .maybeSingle();\n\n  return response;\n}\n\n\n  Future<void> addItem(\n    String name,\n    int quantity,\n    DateTime expDate,\n    int action, // 0 for offer, 1 for trade\n    double latitude,\n    double longitude,\n    String description,\n    File imageFile,\n  ) async {\n    if (_loggedInUsername == null || _userId == null) {\n      throw Exception('User is not logged in');\n    }\n\n    // Upload the image to Supabase Storage\n    final imagePath =\n        'item-images/${DateTime.now().millisecondsSinceEpoch}_${imageFile.path.split('/').last}';\n    final storageResponse = await _client.storage\n        .from('item-images')\n        .upload(imagePath, imageFile);\n\n    if (storageResponse.isEmpty) {\n      throw Exception(\n        'Error uploading image: Upload failed or returned empty response.',\n      );\n    }\n\n    final imageUrl = _client.storage\n        .from('item-images')\n        .getPublicUrl(imagePath);\n\n    try {\n      // Insert the item into the database\n      final response =\n          await _client.from('items').insert({\n            'name': name,\n            'quantity': quantity,\n            'expirationDate': expDate.toIso8601String(),\n            'action': action, // 0 for offer, 1 for trade\n            'latitude': latitude,\n            'longitude': longitude,\n            'description': description,\n            'image': imageUrl, // Save the image URL\n            'user_id': _userId, // Add the user ID\n          }).select();\n\n      print('Insert Response: $response'); // Log the response for debugging\n\n      if (response.isEmpty) {\n        throw Exception('Error adding item: Empty response from Supabase');\n      }\n    } catch (e) {\n      print('Error inserting item: $e'); // Log the error\n      throw Exception(\n        'Error adding item: $e',\n      ); // Re-throw the error with details\n    }\n  }\n\n\n  // Delete an item from the Supabase database\n  Future<void> deleteItem(int id) async {\n    final response = await _client\n        .from('items')\n        .update({'is_deleted': true})  // Mark the item as deleted\n        .eq('id', id)\n        .select();\n        \n    if (response.isEmpty) {\n      throw Exception('Error deleting item');\n    }\n  }\n\n  // Sign in a user\n  Future<bool> signIn(String username, String password) async {\n    final response =\n        await _client\n            .from('User')\n            .select('id')\n            .eq('username', username)\n            .eq('password', password)\n            .maybeSingle();\n\n    if (response != null && response['id'] != null) {\n      _loggedInUsername = username;\n      _userId = response['id'];\n      print(\n        'Login successful. Username: $_loggedInUsername, User ID: $_userId',\n      );\n      return true;\n    } else {\n      print('Login failed. Invalid username or password.');\n      return false;\n    }\n  }\n\n  // Sign up a new user\n  Future<void> signUp(\n    String name,\n    String username,\n    String email,\n    String password,\n    String location,\n  ) async {\n\n    final response = await _client.from('User').insert({\n      'username': username,\n      'name': name,\n      'email': email,\n      'password': password,\n      'location': location,\n    });\n  }\n\n  void signOut() {\n    _loggedInUsername = null;\n    _userId = null;\n    print('User signed out');\n  }\n\n  Future<List<Message>> getMessages(int itemId, int receiverId) async {\n    final response = await _client\n        .from('messages')\n        .select()\n        .eq('item_id', itemId)\n        .or(\n        'and(sender_id.eq.$_userId,receiver_id.eq.$receiverId),' +\n        'and(sender_id.eq.$receiverId,receiver_id.eq.$_userId)')\n        .order('created_at', ascending: true);\n\n    final messages = response.map((e) => Message.fromMap(e)).toList();\n    return messages;\n  }\n\n  Future<void> sendMessage(Message message) async {\n    final messageMap = message.toMap();\n    final response = await _client.from('messages').insert(messageMap);\n  }\n\n  void subscribeToMessages({required int itemId, required Function(Message) onNewMessage, }) {\n    if(_userId == null) return;\n\n    _messageChannel = _client.channel('messages_channel');\n    \n    _messageChannel!.onPostgresChanges(\n      event: PostgresChangeEvent.insert,\n      schema: 'public',\n      table: 'messages',\n      callback: (payload) {\n        final data = payload.newRecord;\n        if(data == null) return;\n\n        final message = Message.fromMap(data);\n\n        if(message.itemId == itemId && (message.senderId == _userId || message.receiverId == _userId)) {\n          onNewMessage(message);\n        }\n      },\n    ).subscribe();\n  }\n\n  void unsubscribeFromMessages() {\n    if(_messageChannel != null) {\n      _client.removeChannel(_messageChannel!);\n      _messageChannel = null;\n    }\n  }\n\n  Future<List<ChatPreview>> getUserChats(int currentUserId) async {\n    try {\n      final response = await _client\n          .from('messages')\n          .select('*, users:receiver_id(username)')\n          .or('sender_id.eq.$currentUserId,receiver_id.eq.$currentUserId')\n          .order('created_at', ascending: false);\n\n      Map<int, ChatPreview> chatMap = {};\n\n      for (var item in response) {\n        final int senderId = item['sender_id'];\n        final int receiverId = item['receiver_id'];\n        final int otherUserId = senderId == currentUserId ? receiverId : senderId;\n\n        // Avoid adding duplicate chats\n        if (!chatMap.containsKey(otherUserId)) {\n          chatMap[otherUserId] = ChatPreview(\n            chatId: item['item_id'],\n            userId: otherUserId,\n            username: item['users']['username'],\n            lastMessage: item['content'],\n            lastMessageTime: DateTime.parse(item['created_at']),\n          );\n        }\n      }\n\n      return chatMap.values.toList();\n    } catch (e) {\n      print('Error getting user chats: $e');\n      return [];\n    }\n  }\n\n  String? get currentUsername => _loggedInUsername;\n  int? get currentUserId => _userId;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hand2hand/lib/supabase_service.dart b/hand2hand/lib/supabase_service.dart
--- a/hand2hand/lib/supabase_service.dart	(revision f57ad7e069a4e4d5f8c7b1aa7ae42311fbe554bb)
+++ b/hand2hand/lib/supabase_service.dart	(date 1747131041996)
@@ -1,7 +1,7 @@
-import 'package:hand2hand/chatpreview.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'dart:io';
 import 'package:hand2hand/message.dart';
+import 'package:hand2hand/chatpreview.dart';
 
 class SupabaseService {
   // Singleton implementation
@@ -24,8 +24,16 @@
     return _client
         .from('items')
         .stream(primaryKey: ['id'])
-        .eq('user_id', _userId!)
-        .map((data) => List<Map<String, dynamic>>.from(data));
+        .map(
+          (items) =>
+              items
+                  .where(
+                    (item) =>
+                        item['user_id'] == _userId &&
+                        item['is_deleted'] == false,
+                  )
+                  .toList(),
+        );
   }
 
   Stream<List<Map<String, dynamic>>> streamOtherUsersItems() {
@@ -33,76 +41,278 @@
       throw Exception('User is not logged in');
     }
 
-    return _client
+    final query = _client
         .from('items')
-        .stream(primaryKey: ['id'])
+        .select()
         .neq('user_id', _userId!)
-        .map((data) => List<Map<String, dynamic>>.from(data));
+        .eq('is_deleted', false);
+
+    return query.asStream().map(
+      (data) => List<Map<String, dynamic>>.from(data),
+    );
   }
 
   Future<Map<String, dynamic>> getItemStatus(int itemId) async {
-  final response = await _client
-      .from('items')
-      .select('is_requested, is_deleted, user_id')
-      .eq('id', itemId)
-      .maybeSingle();
+    final response =
+        await _client
+            .from('items')
+            .select('is_requested, is_deleted, user_id')
+            .eq('id', itemId)
+            .maybeSingle();
 
-  if (response != null) {
-    return {
-      'available': !response['is_requested'] && !response['is_deleted'],
-      'is_requested': response['is_requested'],
-      'is_deleted': response['is_deleted'],
-      'user_id': response['user_id'],
-    };
-  }
-  return {'available': false};
-}
+    if (response != null) {
+      return {
+        'available': !response['is_requested'] && !response['is_deleted'],
+        'is_requested': response['is_requested'],
+        'is_deleted': response['is_deleted'],
+        'user_id': response['user_id'],
+      };
+    }
+    return {'available': false};
+  }
 
-  // Request an item (mark it as requested)
   Future<bool> requestItem(int itemId) async {
-  try {
-    final currentUserId = _userId;
-    if (currentUserId == null) {
-      throw Exception('User not logged in');
-    }
+    try {
+      if (_userId == null) throw Exception('User is not logged in');
+
+      // Check if item is still available
+      final item = await getItemStatus(itemId);
+      if (!item['available']) {
+        print('Item is not available.');
+        return false;
+      }
+
+      // Check if the user already requested this item
+      final existing =
+          await _client
+              .from('requests')
+              .select()
+              .eq('item_id', itemId)
+              .eq('requester_id', _userId!)
+              .maybeSingle();
+
+      if (existing != null) {
+        print('User already requested this item.');
+        return false;
+      }
 
-    final response = await _client
-        .from('items')
-        .update({
-          'is_requested': true,
-          'requested_by': currentUserId, // Track who requested it
-          'requested_at': DateTime.now().toIso8601String(),
-        })
-        .eq('id', itemId)
-        .select();
+      // Insert new request
+      final response = await _client.from('requests').insert({
+        'item_id': itemId,
+        'requester_id': _userId,
+        'owner_id': item['user_id'],
+        'status': 'pending',
+      });
 
-    return response.isNotEmpty;
-  } catch (e) {
-    print('Error requesting item: $e');
-    return false;
-  }
-}
+      return true;
+    } catch (e) {
+      print('Error requesting item: $e');
+      return false;
+    }
+  }
 
+  Future<void> respondToRequest({
+    required int requestId,
+    required bool accepted,
+  }) async {
+    if (_userId == null) throw Exception('User not logged in');
+
+    final responseText = accepted ? "accepted" : "declined";
+
+    // 1. Update the request's status
+    await _client
+        .from('requests')
+        .update({'status': responseText})
+        .eq('id', requestId);
+
+    // 2. Fetch request details
+    final request =
+        await _client
+            .from('requests')
+            .select('requester_id, item_id')
+            .eq('id', requestId)
+            .maybeSingle();
+
+    if (request == null) return;
+
+    final requesterId = request['requester_id'];
+    final itemId = request['item_id'];
+
+    // 3. Get item name for message
+    final item = await getItemById(itemId);
+    final itemName = item?['name'] ?? 'your item';
+
+    // 4. (Optional) Fetch current user details for better messaging
+    final currentUser = await getCurrentUserData();
+    final currentUserName = currentUser?['name'] ?? 'Someone';
+
+    // 5. Insert a notification
+    await _client.from('notifications').insert({
+      'recipient_id': requesterId,
+      'title': 'Request $responseText',
+      'body':
+          '$currentUserName has $responseText your request for "$itemName".',
+      'type': 'response',
+      'data': {
+        'request_id': requestId,
+        'item_id': itemId,
+        'accepted': accepted,
+      },
+      'read': false,
+      'created_at': DateTime.now().toIso8601String(),
+    });
+  }
+
+  Stream<List<Map<String, dynamic>>> streamNotifications() {
+    if (_userId == null) {
+      throw Exception('User not logged in');
+    }
+
+    return _client
+        .from('notifications')
+        .stream(primaryKey: ['id'])
+        .eq('user_id', _userId!)
+        .order('created_at', ascending: false)
+        .map((data) => List<Map<String, dynamic>>.from(data));
+  }
+
   Future<Map<String, dynamic>?> getUserById(int userId) async {
-  final response = await _client
-      .from('User')
-      .select('id, name, username, location')
-      .eq('id', userId)
-      .maybeSingle();
+    final response =
+        await _client
+            .from('User')
+            .select('id, name, username,email, location')
+            .eq('id', userId)
+            .maybeSingle();
 
-  return response;
-}
+    return response;
+  }
 
+  Future<Map<String, dynamic>?> getCurrentUserData() async {
+    if (_userId == null) return null;
+
+    final user = await getUserById(_userId!);
+    return user;
+  }
+
+  Future<void> updateUserProfile({
+    required int userId,
+    required String name,
+    required String username,
+    required String email,
+    required String location,
+  }) async {
+    await _client
+        .from('User')
+        .update({
+          'name': name,
+          'username': username,
+          'email': email,
+          'location': location,
+        })
+        .eq('id', userId);
+  }
+
+  Future<Map<String, dynamic>?> getItemById(int itemId) async {
+    final response =
+        await _client
+            .from('items')
+            .select('id, name')
+            .eq('id', itemId)
+            .maybeSingle();
+    return response;
+  }
+
+  Stream<List<Map<String, dynamic>>> streamIncomingRequests() async* {
+    if (_userId == null) {
+      throw Exception('User not logged in');
+    }
+
+    while (true) {
+      final response = await _client
+          .from('requests')
+          .select(
+            'id, created_at, status, item_id, requester_id, owner_id, requester:User(name), item:item_id(name)',
+          )
+          .eq('owner_id', _userId!)
+          .eq('status', 'pending')
+          .order('created_at');
+
+      yield List<Map<String, dynamic>>.from(response);
+      await Future.delayed(Duration(seconds: 5)); // Polling every 5 seconds
+    }
+  }
+
+  Stream<List<Map<String, dynamic>>> streamPendingExchanges() {
+    if (_userId == null) throw Exception('User not logged in');
+
+    return _client
+        .from('requests')
+        .stream(primaryKey: ['id'])
+        .eq('status', 'pending')
+        .map(
+          (requests) =>
+              requests
+                  .where(
+                    (r) =>
+                        r['requester_id'] == _userId ||
+                        r['owner_id'] == _userId,
+                  )
+                  .toList(),
+        );
+  }
+
+  Future<void> confirmExchange(int requestId) async {
+    if (_userId == null) throw Exception('User not logged in');
+
+    final request =
+        await _client
+            .from('requests')
+            .select(
+              'requester_id, owner_id, requester_confirmed, owner_confirmed',
+            )
+            .eq('id', requestId)
+            .maybeSingle();
+
+    if (request == null) throw Exception('Request not found');
+
+    final isRequester = request['requester_id'] == _userId;
+    final updateField = isRequester ? 'requester_confirmed' : 'owner_confirmed';
+
+    await _client
+        .from('requests')
+        .update({updateField: true})
+        .eq('id', requestId);
+
+    final updated =
+        await _client
+            .from('requests')
+            .select('requester_confirmed, owner_confirmed')
+            .eq('id', requestId)
+            .maybeSingle();
+
+    if (updated != null &&
+        updated['requester_confirmed'] == true &&
+        updated['owner_confirmed'] == true) {
+      await _client
+          .from('requests')
+          .update({'status': 'completed'})
+          .eq('id', requestId);
+
+    }
+  }
+
+  
 
   Future<void> addItem(
     String name,
     int quantity,
     DateTime expDate,
     int action, // 0 for offer, 1 for trade
-    double latitude,
-    double longitude,
+    double latitude, // Updated to accept latitude
+    double longitude, // Updated to accept longitude
     String description,
     File imageFile,
+    String? category,
   ) async {
     if (_loggedInUsername == null || _userId == null) {
       throw Exception('User is not logged in');
@@ -133,11 +343,12 @@
             'quantity': quantity,
             'expirationDate': expDate.toIso8601String(),
             'action': action, // 0 for offer, 1 for trade
-            'latitude': latitude,
-            'longitude': longitude,
+            'latitude': latitude, // Save latitude
+            'longitude': longitude, // Save longitude
             'description': description,
             'image': imageUrl, // Save the image URL
             'user_id': _userId, // Add the user ID
+            'category': category, // Default category
           }).select();
 
       print('Insert Response: $response'); // Log the response for debugging
@@ -153,15 +364,15 @@
     }
   }
 
-
   // Delete an item from the Supabase database
   Future<void> deleteItem(int id) async {
-    final response = await _client
-        .from('items')
-        .update({'is_deleted': true})  // Mark the item as deleted
-        .eq('id', id)
-        .select();
-        
+    final response =
+        await _client
+            .from('items')
+            .update({'is_deleted': true})
+            .eq('id', id)
+            .select();
+
     if (response.isEmpty) {
       throw Exception('Error deleting item');
     }
@@ -198,7 +409,6 @@
     String password,
     String location,
   ) async {
-
     final response = await _client.from('User').insert({
       'username': username,
       'name': name,
@@ -221,7 +431,7 @@
         .eq('item_id', itemId)
         .or(
         'and(sender_id.eq.$_userId,receiver_id.eq.$receiverId),' +
-        'and(sender_id.eq.$receiverId,receiver_id.eq.$_userId)')
+            'and(sender_id.eq.$receiverId,receiver_id.eq.$_userId)')
         .order('created_at', ascending: true);
 
     final messages = response.map((e) => Message.fromMap(e)).toList();
@@ -237,7 +447,7 @@
     if(_userId == null) return;
 
     _messageChannel = _client.channel('messages_channel');
-    
+
     _messageChannel!.onPostgresChanges(
       event: PostgresChangeEvent.insert,
       schema: 'public',
