Index: hand2hand/lib/navigation_helper.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'package:flutter/material.dart';\nimport 'screens/my_items_screen.dart';\nimport 'sign_up_screen.dart';\nimport 'sign_in_screen.dart'; // Import the SignInScreen\n\nvoid navigateToBrowseItemsScreen(BuildContext context) {\n  Navigator.push(\n    context,\n    MaterialPageRoute(builder: (context) => MyItemsScreen()),\n  );\n}\n\nvoid navigateToSignUpScreen(BuildContext context) {\n  Navigator.push(\n    context,\n    MaterialPageRoute(builder: (context) => SignUpScreen()),\n  );\n}\n\nvoid navigateToSignInScreen(BuildContext context) {\n  Navigator.push(\n    context,\n    MaterialPageRoute(builder: (context) => SignInScreen()),\n  );\n}\n\nvoid navigateWithTransition(BuildContext context, Widget page) {\n  Navigator.push(\n    context,\n    PageRouteBuilder(\n        pageBuilder: (context, animation, secondaryAnimation) => page,\n        transitionsBuilder: (context, animation, secondaryAnimation, child) {\n          const begin = Offset(1.0, 0.0);\n          const end = Offset.zero;\n          const curve = Curves.easeInOut;\n\n          var tween = Tween(begin: begin, end: end).chain(CurveTween(curve: curve));\n          var offsetAnimation = animation.drive(tween);\n\n          var scaleTween = Tween(begin: 0.95, end: 1.0).chain(CurveTween(curve: Curves.easeOut));\n          var scaleAnimation = animation.drive(scaleTween);\n\n          var opacityTween = Tween(begin: 0.0, end: 1.0).chain(CurveTween(curve: Curves.easeInOut));\n          var opacityAnimation = animation.drive(opacityTween);\n\n          return SlideTransition(position: offsetAnimation, child:ScaleTransition(scale: scaleAnimation, child: FadeTransition(opacity: opacityAnimation, child: child,),),);\n        },\n    ),\n  );\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hand2hand/lib/navigation_helper.dart b/hand2hand/lib/navigation_helper.dart
--- a/hand2hand/lib/navigation_helper.dart	(revision 469ee9db27df25c4a3f2b304ab0d6073e0dbe206)
+++ b/hand2hand/lib/navigation_helper.dart	(date 1747132722891)
@@ -24,27 +24,28 @@
   );
 }
 
+
 void navigateWithTransition(BuildContext context, Widget page) {
   Navigator.push(
     context,
     PageRouteBuilder(
-        pageBuilder: (context, animation, secondaryAnimation) => page,
-        transitionsBuilder: (context, animation, secondaryAnimation, child) {
-          const begin = Offset(1.0, 0.0);
-          const end = Offset.zero;
-          const curve = Curves.easeInOut;
+      pageBuilder: (context, animation, secondaryAnimation) => page,
+      transitionsBuilder: (context, animation, secondaryAnimation, child) {
+        const begin = Offset(1.0, 0.0);
+        const end = Offset.zero;
+        const curve = Curves.easeInOut;
 
-          var tween = Tween(begin: begin, end: end).chain(CurveTween(curve: curve));
-          var offsetAnimation = animation.drive(tween);
+        var tween = Tween(begin: begin, end: end).chain(CurveTween(curve: curve));
+        var offsetAnimation = animation.drive(tween);
 
-          var scaleTween = Tween(begin: 0.95, end: 1.0).chain(CurveTween(curve: Curves.easeOut));
-          var scaleAnimation = animation.drive(scaleTween);
+        var scaleTween = Tween(begin: 0.95, end: 1.0).chain(CurveTween(curve: Curves.easeOut));
+        var scaleAnimation = animation.drive(scaleTween);
 
-          var opacityTween = Tween(begin: 0.0, end: 1.0).chain(CurveTween(curve: Curves.easeInOut));
-          var opacityAnimation = animation.drive(opacityTween);
+        var opacityTween = Tween(begin: 0.0, end: 1.0).chain(CurveTween(curve: Curves.easeInOut));
+        var opacityAnimation = animation.drive(opacityTween);
 
-          return SlideTransition(position: offsetAnimation, child:ScaleTransition(scale: scaleAnimation, child: FadeTransition(opacity: opacityAnimation, child: child,),),);
-        },
+        return SlideTransition(position: offsetAnimation, child:ScaleTransition(scale: scaleAnimation, child: FadeTransition(opacity: opacityAnimation, child: child,),),);
+      },
     ),
   );
 }
Index: hand2hand/lib/screens/chatscreen_page.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'package:flutter/material.dart';\nimport 'package:google_fonts/google_fonts.dart';\nimport 'package:hand2hand/message.dart';\nimport 'package:hand2hand/navigation_helper.dart';\nimport 'package:hand2hand/screens/chatlist_page.dart';\nimport 'package:hand2hand/supabase_service.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\nclass ChatScreen extends StatefulWidget {\n  final int itemId;\n  final int receiverId;\n\n  const ChatScreen({Key? key, required this.itemId, required this.receiverId})\n    : super(key: key);\n\n  @override\n  _ChatScreenState createState() => _ChatScreenState();\n}\n\nclass _ChatScreenState extends State<ChatScreen> {\n  final _controller = TextEditingController();\n  final _messages = <Message>[];\n  Map<int, String> _usernamesCache = {};\n  bool _isLoading = false;\n  RealtimeChannel? _messageChannel;\n  String _receiverUsername = '';\n\n  @override\n  void initState() {\n    super.initState();\n    _loadMessages();\n    _loadReceiverUsername();\n\n    SupabaseService().subscribeToMessages (itemId: widget.itemId, onNewMessage: (Message newMessage) async {\n        if (!_usernamesCache.containsKey(newMessage.senderId)) {\n          final user = await SupabaseService().getUserById(newMessage.senderId);\n          _usernamesCache[newMessage.senderId] = user?['username'] ?? 'Unknown';\n        }\n\n        setState(() {\n          _messages.add(newMessage);\n        });\n      },\n    );\n  }\n\n  @override\n  void dispose() {\n    SupabaseService().unsubscribeFromMessages();\n    super.dispose();\n  }\n\n  Future<void> _sendMessage() async {\n    if(_controller.text.isEmpty) return;\n\n    try {\n      final currentUserId = SupabaseService().currentUserId!;\n      final message = Message(\n        senderId: currentUserId,\n        receiverId: widget.receiverId,\n        itemId: widget.itemId,\n        content: _controller.text,\n        createdAt: DateTime.now(),\n      );\n\n      await SupabaseService().sendMessage(message);\n\n      setState(() {\n        _messages.add(message);\n        _controller.clear();\n      });\n    }\n\n    catch(e) {\n      print('Error sending message: $e');\n    }\n  }\n\n  Future<void> _loadMessages() async {\n    try {\n      setState(() => _isLoading = true);\n      final messages = await SupabaseService().getMessages(widget.itemId, widget.receiverId);\n      \n      for(var message in messages) {\n        if(!_usernamesCache.containsKey(message.senderId)){\n          final user = await SupabaseService().getUserById(message.senderId);\n\n          if(user != null) {\n            _usernamesCache[message.senderId] = user['username'];\n          }\n\n          else {\n            _usernamesCache[message.senderId] = 'Unknown';\n          }\n        }\n      }\n      \n      setState(() {\n        _messages.addAll(messages);\n      });\n    }\n\n    catch (e) {\n      print('Error loading messages: $e');\n    }\n\n    finally {\n      setState(() => _isLoading = false);\n    }\n  }\n\n  Future<void> _loadReceiverUsername() async {\n    final user = await SupabaseService().getUserById(widget.receiverId);\n    setState(() {\n      _receiverUsername = user?['username'] ?? 'unknown';\n    });\n  }\n\n  Widget _buildMessageBubble(Message message) {\n    final isMe = message.senderId == SupabaseService().currentUserId;\n    final alignment = isMe ? Alignment.centerRight : Alignment.centerLeft;\n    final bubbleColor = isMe ? Color.fromARGB(223, 255, 233, 153): Colors.grey[300];\n\n    return Align(\n      alignment: alignment,\n      child: Container(\n        margin: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 8.0),\n        padding: const EdgeInsets.symmetric(vertical: 10.0, horizontal: 14.0),\n        constraints: BoxConstraints(maxWidth: MediaQuery.of(context).size.width * 0.7),\n        decoration: BoxDecoration(\n          color: bubbleColor,\n          borderRadius: BorderRadius.circular(16.0),\n        ),\n        child: Text(\n          message.content,\n          style: GoogleFonts.outfit(\n            fontSize: 16,\n            color: Colors.black87,\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        automaticallyImplyLeading: false,\n        leading: IconButton (\n          icon: Icon(Icons.arrow_back_ios, color: Color.fromARGB(255, 222, 79, 79)),\n          onPressed: () {\n            navigateWithTransition(context, ChatListPage());\n          },\n        ),\n        title: Text(\n          _receiverUsername,\n          style: GoogleFonts.outfit(\n            fontSize: 26,\n            color: Color.fromARGB(255, 222, 79, 79),\n          ),\n        ),\n        backgroundColor: Color.fromARGB(223, 255, 213, 63),\n        elevation: 0,\n      ),\n\n      body: SafeArea(\n        child: Column(\n          children: [\n            Expanded(\n              child: _isLoading\n                  ? const Center(child: CircularProgressIndicator())\n                  : ListView.builder(\n                    reverse: false,\n                    itemCount: _messages.length,\n                    itemBuilder: (context, index) {\n                      final message = _messages[index];\n                      return _buildMessageBubble(message);\n                    },\n                  ),\n            ),\n\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: Row(\n                children: [\n                  Expanded(\n                    child: TextField(\n                      controller: _controller,\n                      decoration: InputDecoration(\n                        hintText: 'Type a message...',\n                        hintStyle: TextStyle(color: Colors.grey[500]),\n                        filled: true,\n                        fillColor: Colors.white,\n                        contentPadding: EdgeInsets.symmetric(vertical: 10, horizontal: 15),\n                        border: OutlineInputBorder(\n                          borderRadius: BorderRadius.circular(30),\n                          borderSide: BorderSide(color: Colors.grey[300]!, width: 1),\n                        ),\n                        enabledBorder: OutlineInputBorder(\n                          borderRadius: BorderRadius.circular(30),\n                          borderSide: BorderSide(color: Colors.grey[300]!, width: 1),\n                        ),\n                        focusedBorder: OutlineInputBorder(\n                          borderRadius: BorderRadius.circular(30),\n                          borderSide: BorderSide(color: Color.fromARGB(223, 255, 213, 63), width: 2),\n                        )\n                      ),\n                    ),\n                  ),\n                  SizedBox(width: 8),\n                  GestureDetector(\n                    onTap: _sendMessage,\n                    child: Container(\n                      padding: EdgeInsets.all(12),\n                      decoration: BoxDecoration(\n                        color: Color.fromARGB(255, 222, 79, 79),\n                        shape: BoxShape.circle,\n                        boxShadow: [\n                          BoxShadow(\n                            color: Colors.black26,\n                            blurRadius: 4,\n                            offset: Offset(2, 2),\n                          ),\n                        ],\n                      ),\n                      child : Icon(\n                        Icons.send,\n                        color: Colors.white,\n                        size: 24,\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hand2hand/lib/screens/chatscreen_page.dart b/hand2hand/lib/screens/chatscreen_page.dart
--- a/hand2hand/lib/screens/chatscreen_page.dart	(revision 469ee9db27df25c4a3f2b304ab0d6073e0dbe206)
+++ b/hand2hand/lib/screens/chatscreen_page.dart	(date 1747132771852)
@@ -11,7 +11,7 @@
   final int receiverId;
 
   const ChatScreen({Key? key, required this.itemId, required this.receiverId})
-    : super(key: key);
+      : super(key: key);
 
   @override
   _ChatScreenState createState() => _ChatScreenState();
@@ -32,15 +32,15 @@
     _loadReceiverUsername();
 
     SupabaseService().subscribeToMessages (itemId: widget.itemId, onNewMessage: (Message newMessage) async {
-        if (!_usernamesCache.containsKey(newMessage.senderId)) {
-          final user = await SupabaseService().getUserById(newMessage.senderId);
-          _usernamesCache[newMessage.senderId] = user?['username'] ?? 'Unknown';
-        }
+      if (!_usernamesCache.containsKey(newMessage.senderId)) {
+        final user = await SupabaseService().getUserById(newMessage.senderId);
+        _usernamesCache[newMessage.senderId] = user?['username'] ?? 'Unknown';
+      }
 
-        setState(() {
-          _messages.add(newMessage);
-        });
-      },
+      setState(() {
+        _messages.add(newMessage);
+      });
+    },
     );
   }
 
@@ -80,7 +80,7 @@
     try {
       setState(() => _isLoading = true);
       final messages = await SupabaseService().getMessages(widget.itemId, widget.receiverId);
-      
+
       for(var message in messages) {
         if(!_usernamesCache.containsKey(message.senderId)){
           final user = await SupabaseService().getUserById(message.senderId);
@@ -94,7 +94,7 @@
           }
         }
       }
-      
+
       setState(() {
         _messages.addAll(messages);
       });
@@ -171,13 +171,13 @@
               child: _isLoading
                   ? const Center(child: CircularProgressIndicator())
                   : ListView.builder(
-                    reverse: false,
-                    itemCount: _messages.length,
-                    itemBuilder: (context, index) {
-                      final message = _messages[index];
-                      return _buildMessageBubble(message);
-                    },
-                  ),
+                reverse: false,
+                itemCount: _messages.length,
+                itemBuilder: (context, index) {
+                  final message = _messages[index];
+                  return _buildMessageBubble(message);
+                },
+              ),
             ),
 
             Padding(
@@ -188,23 +188,23 @@
                     child: TextField(
                       controller: _controller,
                       decoration: InputDecoration(
-                        hintText: 'Type a message...',
-                        hintStyle: TextStyle(color: Colors.grey[500]),
-                        filled: true,
-                        fillColor: Colors.white,
-                        contentPadding: EdgeInsets.symmetric(vertical: 10, horizontal: 15),
-                        border: OutlineInputBorder(
-                          borderRadius: BorderRadius.circular(30),
-                          borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
-                        ),
-                        enabledBorder: OutlineInputBorder(
-                          borderRadius: BorderRadius.circular(30),
-                          borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
-                        ),
-                        focusedBorder: OutlineInputBorder(
-                          borderRadius: BorderRadius.circular(30),
-                          borderSide: BorderSide(color: Color.fromARGB(223, 255, 213, 63), width: 2),
-                        )
+                          hintText: 'Type a message...',
+                          hintStyle: TextStyle(color: Colors.grey[500]),
+                          filled: true,
+                          fillColor: Colors.white,
+                          contentPadding: EdgeInsets.symmetric(vertical: 10, horizontal: 15),
+                          border: OutlineInputBorder(
+                            borderRadius: BorderRadius.circular(30),
+                            borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
+                          ),
+                          enabledBorder: OutlineInputBorder(
+                            borderRadius: BorderRadius.circular(30),
+                            borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
+                          ),
+                          focusedBorder: OutlineInputBorder(
+                            borderRadius: BorderRadius.circular(30),
+                            borderSide: BorderSide(color: Color.fromARGB(223, 255, 213, 63), width: 2),
+                          )
                       ),
                     ),
                   ),
Index: hand2hand/lib/screens/chatlist_page.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'package:flutter/material.dart';\nimport 'package:google_fonts/google_fonts.dart';\nimport 'package:hand2hand/chatpreview.dart';\nimport 'package:hand2hand/navigation_helper.dart';\nimport 'package:hand2hand/screens/explorer_page.dart';\nimport 'package:hand2hand/screens/navController.dart';\nimport 'package:hand2hand/supabase_service.dart';\nimport 'chatscreen_page.dart';\n\nclass ChatListPage extends StatefulWidget {\n  @override\n  _ChatListPageState createState() => _ChatListPageState();\n}\n\nclass _ChatListPageState extends State<ChatListPage> {\n  List<ChatPreview> _chats = [];\n  bool _isLoading = true;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadChats();\n  }\n\n  Future<void> _loadChats() async {\n    try {\n      final currentUserId = await SupabaseService().currentUserId!;\n      final chats = await SupabaseService().getUserChats(currentUserId);\n      setState(() {\n        _chats = chats;\n        _isLoading = false;\n      });\n    }\n    catch (e) {\n      print(\"Error loading chats: $e\");\n      setState(() {\n        _isLoading = false;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        automaticallyImplyLeading: false,\n        leading: IconButton(\n          icon: Icon(Icons.arrow_back_ios, color: Color.fromARGB(255, 222, 79, 79)),\n          onPressed: () {\n            navigateWithTransition(context, HomePage());\n          },\n        ),\n        title: Text(\n          'Messages',\n          style: GoogleFonts.outfit(\n            fontSize: 26,\n            color: Color.fromARGB(255, 222, 79, 79),\n          ),\n        ),\n        backgroundColor: Color.fromARGB(223, 255, 213, 63),\n        elevation: 0,\n      ),\n\n      body: _isLoading\n        ? Center(child: CircularProgressIndicator())\n        : ListView.builder(\n            itemCount: _chats.length,\n            itemBuilder: (context, index) {\n              final chat = _chats[index];\n              return ListTile(\n                title: Text(chat.username),\n                subtitle: Text(chat.lastMessage),\n                trailing: Text(\"${chat.lastMessageTime.hour}:${chat.lastMessageTime.minute}\"),\n                onTap: () {\n                  navigateWithTransition(context, ChatScreen(itemId: chat.chatId, receiverId: chat.userId,),\n                  );\n                },\n              );\n            },\n      ),\n    );\n  }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hand2hand/lib/screens/chatlist_page.dart b/hand2hand/lib/screens/chatlist_page.dart
--- a/hand2hand/lib/screens/chatlist_page.dart	(revision 469ee9db27df25c4a3f2b304ab0d6073e0dbe206)
+++ b/hand2hand/lib/screens/chatlist_page.dart	(date 1747132796636)
@@ -62,21 +62,21 @@
       ),
 
       body: _isLoading
-        ? Center(child: CircularProgressIndicator())
-        : ListView.builder(
-            itemCount: _chats.length,
-            itemBuilder: (context, index) {
-              final chat = _chats[index];
-              return ListTile(
-                title: Text(chat.username),
-                subtitle: Text(chat.lastMessage),
-                trailing: Text("${chat.lastMessageTime.hour}:${chat.lastMessageTime.minute}"),
-                onTap: () {
-                  navigateWithTransition(context, ChatScreen(itemId: chat.chatId, receiverId: chat.userId,),
-                  );
-                },
-              );
-            },
+          ? Center(child: CircularProgressIndicator())
+          : ListView.builder(
+        itemCount: _chats.length,
+        itemBuilder: (context, index) {
+          final chat = _chats[index];
+          return ListTile(
+            title: Text(chat.username),
+            subtitle: Text(chat.lastMessage),
+            trailing: Text("${chat.lastMessageTime.hour}:${chat.lastMessageTime.minute}"),
+            onTap: () {
+              navigateWithTransition(context, ChatScreen(itemId: chat.chatId, receiverId: chat.userId,),
+              );
+            },
+          );
+        },
       ),
     );
   }
Index: hand2hand/lib/supabase_service.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'package:supabase_flutter/supabase_flutter.dart';\nimport 'dart:io';\nimport 'package:hand2hand/message.dart';\n\nclass SupabaseService {\n  // Singleton implementation\n  SupabaseService._privateConstructor();\n  static final SupabaseService _instance =\n      SupabaseService._privateConstructor();\n  factory SupabaseService() => _instance;\n\n  final _client = Supabase.instance.client;\n  String? _loggedInUsername; // Store the logged-in username\n  int? _userId; // Cache the logged-in user's ID\n  RealtimeChannel? _messageChannel;\n\n  // Stream items from the Supabase database for the logged-in user\n  Stream<List<Map<String, dynamic>>> streamItems() {\n    if (_userId == null) {\n      throw Exception('User is not logged in or user ID not available');\n    }\n\n    return _client\n        .from('items')\n        .stream(primaryKey: ['id'])\n        .map(\n          (items) =>\n              items\n                  .where(\n                    (item) =>\n                        item['user_id'] == _userId &&\n                        item['is_deleted'] == false,\n                  )\n                  .toList(),\n        );\n  }\n\n  Stream<List<Map<String, dynamic>>> streamOtherUsersItems() {\n    if (_userId == null) {\n      throw Exception('User is not logged in');\n    }\n\n    return _client\n        .from('items')\n        .stream(primaryKey: ['id'])\n        .neq('user_id', _userId!)\n        .map((data) => List<Map<String, dynamic>>.from(data));\n  }\n\n  Future<Map<String, dynamic>> getItemStatus(int itemId) async {\n    final response =\n        await _client\n            .from('items')\n            .select('is_requested, is_deleted, user_id')\n            .eq('id', itemId)\n            .maybeSingle();\n\n    if (response != null) {\n      return {\n        'available': !response['is_requested'] && !response['is_deleted'],\n        'is_requested': response['is_requested'],\n        'is_deleted': response['is_deleted'],\n        'user_id': response['user_id'],\n      };\n    }\n    return {'available': false};\n  }\n\n  Future<bool> requestItem(int itemId) async {\n    try {\n      if (_userId == null) throw Exception('User is not logged in');\n\n      // Check if item is still available\n      final item = await getItemStatus(itemId);\n      if (!item['available']) {\n        print('Item is not available.');\n        return false;\n      }\n\n      // Check if the user already requested this item\n      final existing =\n          await _client\n              .from('requests')\n              .select()\n              .eq('item_id', itemId)\n              .eq('requester_id', _userId!)\n              .maybeSingle();\n\n      if (existing != null) {\n        print('User already requested this item.');\n        return false;\n      }\n\n      // Insert new request\n      final response = await _client.from('requests').insert({\n        'item_id': itemId,\n        'requester_id': _userId,\n        'owner_id': item['user_id'],\n        'status': 'pending',\n      });\n\n      return true;\n    } catch (e) {\n      print('Error requesting item: $e');\n      return false;\n    }\n  }\n\n  Future<Map<String, dynamic>?> getUserById(int userId) async {\n    final response =\n        await _client\n            .from('User')\n            .select('id, name, username, location')\n            .eq('id', userId)\n            .maybeSingle();\n\n    return response;\n  }\n\n  Future<Map<String, dynamic>?> getItemById(int itemId) async {\n  final response = await _client\n      .from('items')\n      .select('id, name')\n      .eq('id', itemId)\n      .maybeSingle();\n  return response;\n}\n\n\n  Stream<List<Map<String, dynamic>>> streamIncomingRequests() async* {\n  if (_userId == null) {\n    throw Exception('User not logged in');\n  }\n\n  while (true) {\n    final response = await _client\n        .from('requests')\n        .select('id, created_at, status, item_id, requester_id, owner_id, requester:User(name), item:item_id(name)')\n        .eq('owner_id', _userId!)\n        .eq('status', 'pending')\n        .order('created_at');\n\n    yield List<Map<String, dynamic>>.from(response);\n    await Future.delayed(Duration(seconds: 5)); // Polling every 5 seconds\n  }\n}\n\n\n\n  Future<void> addItem(\n    String name,\n    int quantity,\n    DateTime expDate,\n    int action, // 0 for offer, 1 for trade\n    double latitude, // Updated to accept latitude\n    double longitude, // Updated to accept longitude\n    String description,\n    File imageFile,\n  ) async {\n    if (_loggedInUsername == null || _userId == null) {\n      throw Exception('User is not logged in');\n    }\n\n    // Upload the image to Supabase Storage\n    final imagePath =\n        'item-images/${DateTime.now().millisecondsSinceEpoch}_${imageFile.path.split('/').last}';\n    final storageResponse = await _client.storage\n        .from('item-images')\n        .upload(imagePath, imageFile);\n\n    if (storageResponse.isEmpty) {\n      throw Exception(\n        'Error uploading image: Upload failed or returned empty response.',\n      );\n    }\n\n    final imageUrl = _client.storage\n        .from('item-images')\n        .getPublicUrl(imagePath);\n\n    try {\n      // Insert the item into the database\n      final response =\n          await _client.from('items').insert({\n            'name': name,\n            'quantity': quantity,\n            'expirationDate': expDate.toIso8601String(),\n            'action': action, // 0 for offer, 1 for trade\n            'latitude': latitude, // Save latitude\n            'longitude': longitude, // Save longitude\n            'description': description,\n            'image': imageUrl, // Save the image URL\n            'user_id': _userId, // Add the user ID\n          }).select();\n\n      print('Insert Response: $response'); // Log the response for debugging\n\n      if (response.isEmpty) {\n        throw Exception('Error adding item: Empty response from Supabase');\n      }\n    } catch (e) {\n      print('Error inserting item: $e'); // Log the error\n      throw Exception(\n        'Error adding item: $e',\n      ); // Re-throw the error with details\n    }\n  }\n\n  // Delete an item from the Supabase database\n  Future<void> deleteItem(int id) async {\n    final response =\n        await _client\n            .from('items')\n            .delete()\n            .eq('id', id)\n            .select();\n\n    if (response.isEmpty) {\n      throw Exception('Error deleting item');\n    }\n  }\n\n  // Sign in a user\n  Future<bool> signIn(String username, String password) async {\n    final response =\n        await _client\n            .from('User')\n            .select('id')\n            .eq('username', username)\n            .eq('password', password)\n            .maybeSingle();\n\n    if (response != null && response['id'] != null) {\n      _loggedInUsername = username;\n      _userId = response['id'];\n      print(\n        'Login successful. Username: $_loggedInUsername, User ID: $_userId',\n      );\n      return true;\n    } else {\n      print('Login failed. Invalid username or password.');\n      return false;\n    }\n  }\n\n  // Sign up a new user\n  Future<void> signUp(\n    String name,\n    String username,\n    String email,\n    String password,\n    String location,\n  ) async {\n    final response = await _client.from('User').insert({\n      'username': username,\n      'name': name,\n      'email': email,\n      'password': password,\n      'location': location,\n    });\n  }\n\n  void signOut() {\n    _loggedInUsername = null;\n    _userId = null;\n    print('User signed out');\n  }\n\n  Future<List<Message>> getMessages(int itemId, int receiverId) async {\n    final response = await _client\n        .from('messages')\n        .select()\n        .eq('item_id', itemId)\n        .eq('receiver_id', receiverId)\n        .order('created_at', ascending: true);\n    return (response as List).map((e) => Message.fromMap(e as Map<String, dynamic>)).toList();\n  }\n\n  Future<void> sendMessage(Message message) async {\n    final response = await _client.from('messages').insert(message.toMap());\n\n    if(response == null || response.isEmpty) {\n      throw Exception('Failed to insert message or response was empty.');\n    }\n  }\n\n  void subscribeToMessages({required int itemId, required Function(Message) onNewMessage, }) {\n    if(_userId == null) return;\n\n    _messageChannel = _client.channel('messages_channel');\n    \n    _messageChannel!.onPostgresChanges(\n      event: PostgresChangeEvent.insert,\n      schema: 'public',\n      table: 'messages',\n      callback: (payload) {\n        final data = payload.newRecord;\n        if(data == null) return;\n\n        final message = Message.fromMap(data);\n\n        if(message.itemId == itemId && (message.senderId == _userId || message.receiverId == _userId)) {\n          onNewMessage(message);\n        }\n      },\n    ).subscribe();\n  }\n\n  void unsubscribeFromMessages() {\n    if(_messageChannel != null) {\n      _client.removeChannel(_messageChannel!);\n      _messageChannel = null;\n    }\n  }\n\n  String? get currentUsername => _loggedInUsername;\n  int? get currentUserId => _userId;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hand2hand/lib/supabase_service.dart b/hand2hand/lib/supabase_service.dart
--- a/hand2hand/lib/supabase_service.dart	(revision 469ee9db27df25c4a3f2b304ab0d6073e0dbe206)
+++ b/hand2hand/lib/supabase_service.dart	(date 1747132700246)
@@ -1,6 +1,7 @@
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'dart:io';
 import 'package:hand2hand/message.dart';
+import 'package:hand2hand/chatpreview.dart';
 
 class SupabaseService {
   // Singleton implementation
@@ -271,24 +272,25 @@
         .from('messages')
         .select()
         .eq('item_id', itemId)
-        .eq('receiver_id', receiverId)
+        .or(
+        'and(sender_id.eq.$_userId,receiver_id.eq.$receiverId),' +
+            'and(sender_id.eq.$receiverId,receiver_id.eq.$_userId)')
         .order('created_at', ascending: true);
-    return (response as List).map((e) => Message.fromMap(e as Map<String, dynamic>)).toList();
+
+    final messages = response.map((e) => Message.fromMap(e)).toList();
+    return messages;
   }
 
   Future<void> sendMessage(Message message) async {
-    final response = await _client.from('messages').insert(message.toMap());
-
-    if(response == null || response.isEmpty) {
-      throw Exception('Failed to insert message or response was empty.');
-    }
+    final messageMap = message.toMap();
+    final response = await _client.from('messages').insert(messageMap);
   }
 
   void subscribeToMessages({required int itemId, required Function(Message) onNewMessage, }) {
     if(_userId == null) return;
 
     _messageChannel = _client.channel('messages_channel');
-    
+
     _messageChannel!.onPostgresChanges(
       event: PostgresChangeEvent.insert,
       schema: 'public',
@@ -313,6 +315,40 @@
     }
   }
 
+  Future<List<ChatPreview>> getUserChats(int currentUserId) async {
+    try {
+      final response = await _client
+          .from('messages')
+          .select('*, users:receiver_id(username)')
+          .or('sender_id.eq.$currentUserId,receiver_id.eq.$currentUserId')
+          .order('created_at', ascending: false);
+
+      Map<int, ChatPreview> chatMap = {};
+
+      for (var item in response) {
+        final int senderId = item['sender_id'];
+        final int receiverId = item['receiver_id'];
+        final int otherUserId = senderId == currentUserId ? receiverId : senderId;
+
+        // Avoid adding duplicate chats
+        if (!chatMap.containsKey(otherUserId)) {
+          chatMap[otherUserId] = ChatPreview(
+            chatId: item['item_id'],
+            userId: otherUserId,
+            username: item['users']['username'],
+            lastMessage: item['content'],
+            lastMessageTime: DateTime.parse(item['created_at']),
+          );
+        }
+      }
+
+      return chatMap.values.toList();
+    } catch (e) {
+      print('Error getting user chats: $e');
+      return [];
+    }
+  }
+
   String? get currentUsername => _loggedInUsername;
   int? get currentUserId => _userId;
 }
