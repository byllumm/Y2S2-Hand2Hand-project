Index: hand2hand/lib/supabase_service.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'package:supabase_flutter/supabase_flutter.dart';\nimport 'dart:io';\nimport 'package:hand2hand/message.dart';\nimport 'package:hand2hand/chatpreview.dart';\n\nclass SupabaseService {\n  // Singleton implementation\n  SupabaseService._privateConstructor();\n  static final SupabaseService _instance =\n      SupabaseService._privateConstructor();\n  factory SupabaseService() => _instance;\n\n  final _client = Supabase.instance.client;\n  String? _loggedInUsername; // Store the logged-in username\n  int? _userId; // Cache the logged-in user's ID\n  RealtimeChannel? _messageChannel;\n\n  // Stream items from the Supabase database for the logged-in user\n  Stream<List<Map<String, dynamic>>> streamItems() {\n    if (_userId == null) {\n      throw Exception('User is not logged in or user ID not available');\n    }\n\n    return _client\n        .from('items')\n        .stream(primaryKey: ['id'])\n        .map(\n          (items) =>\n              items\n                  .where(\n                    (item) =>\n                        item['user_id'] == _userId &&\n                        item['is_deleted'] == false,\n                  )\n                  .toList(),\n        );\n  }\n\n  Stream<List<Map<String, dynamic>>> streamOtherUsersItems() {\n    if (_userId == null) {\n      throw Exception('User is not logged in');\n    }\n\n    final query = _client\n        .from('items')\n        .select()\n        .neq('user_id', _userId!)\n        .eq('is_deleted', false);\n\n    return query.asStream().map(\n      (data) => List<Map<String, dynamic>>.from(data),\n    );\n  }\n\n  Future<Map<String, dynamic>> getItemStatus(int itemId) async {\n    final response =\n        await _client\n            .from('items')\n            .select('is_requested, is_deleted, user_id')\n            .eq('id', itemId)\n            .maybeSingle();\n\n    if (response != null) {\n      return {\n        'available': !response['is_requested'] && !response['is_deleted'],\n        'is_requested': response['is_requested'],\n        'is_deleted': response['is_deleted'],\n        'user_id': response['user_id'],\n      };\n    }\n    return {'available': false};\n  }\n\n  Future<bool> requestItem(int itemId) async {\n    try {\n      if (_userId == null) throw Exception('User is not logged in');\n\n      // Check if item is still available\n      final item = await getItemStatus(itemId);\n      if (!item['available']) {\n        print('Item is not available.');\n        return false;\n      }\n\n      // Check if the user already requested this item\n      final existing =\n          await _client\n              .from('requests')\n              .select()\n              .eq('item_id', itemId)\n              .eq('requester_id', _userId!)\n              .maybeSingle();\n\n      if (existing != null) {\n        print('User already requested this item.');\n        return false;\n      }\n\n      // Insert new request\n      final response = await _client.from('requests').insert({\n        'item_id': itemId,\n        'requester_id': _userId,\n        'owner_id': item['user_id'],\n        'status': 'pending',\n      });\n\n      return true;\n    } catch (e) {\n      print('Error requesting item: $e');\n      return false;\n    }\n  }\n\n  Future<void> respondToRequest({\n    required int requestId,\n    required bool accepted,\n  }) async {\n    if (_userId == null) throw Exception('User not logged in');\n\n    final responseText = accepted ? \"accepted\" : \"declined\";\n\n    // 1. Update the request's status\n    await _client\n        .from('requests')\n        .update({'status': responseText})\n        .eq('id', requestId);\n\n    // 2. Fetch request details\n    final request =\n        await _client\n            .from('requests')\n            .select('requester_id, item_id')\n            .eq('id', requestId)\n            .maybeSingle();\n\n    if (request == null) return;\n\n    final requesterId = request['requester_id'];\n    final itemId = request['item_id'];\n\n    // 3. Get item name for message\n    final item = await getItemById(itemId);\n    final itemName = item?['name'] ?? 'your item';\n\n    // 4. (Optional) Fetch current user details for better messaging\n    final currentUser = await getCurrentUserData();\n    final currentUserName = currentUser?['name'] ?? 'Someone';\n\n    // 5. Insert a notification\n    await _client.from('notifications').insert({\n      'recipient_id': requesterId,\n      'title': 'Request $responseText',\n      'body':\n          '$currentUserName has $responseText your request for \"$itemName\".',\n      'type': 'response',\n      'data': {\n        'request_id': requestId,\n        'item_id': itemId,\n        'accepted': accepted,\n      },\n      'read': false,\n      'created_at': DateTime.now().toIso8601String(),\n    });\n  }\n\n  Stream<List<Map<String, dynamic>>> streamNotifications() {\n    if (_userId == null) {\n      throw Exception('User not logged in');\n    }\n\n    return _client\n        .from('notifications')\n        .stream(primaryKey: ['id'])\n        .eq('user_id', _userId!)\n        .order('created_at', ascending: false)\n        .map((data) => List<Map<String, dynamic>>.from(data));\n  }\n\n  Future<Map<String, dynamic>?> getUserById(int userId) async {\n    final response =\n        await _client\n            .from('User')\n            .select('id, name, username,email, location')\n            .eq('id', userId)\n            .maybeSingle();\n\n    return response;\n  }\n\n  Future<Map<String, dynamic>?> getCurrentUserData() async {\n    if (_userId == null) return null;\n\n    final user = await getUserById(_userId!);\n    return user;\n  }\n\n  Future<void> updateUserProfile({\n    required int userId,\n    required String name,\n    required String username,\n    required String email,\n    required String location,\n  }) async {\n    await _client\n        .from('User')\n        .update({\n          'name': name,\n          'username': username,\n          'email': email,\n          'location': location,\n        })\n        .eq('id', userId);\n  }\n\n  Future<Map<String, dynamic>?> getItemById(int itemId) async {\n    final response =\n        await _client\n            .from('items')\n            .select('id, name')\n            .eq('id', itemId)\n            .maybeSingle();\n    return response;\n  }\n\n  Stream<List<Map<String, dynamic>>> streamIncomingRequests() async* {\n    if (_userId == null) {\n      throw Exception('User not logged in');\n    }\n\n    while (true) {\n      final response = await _client\n          .from('requests')\n          .select(\n            'id, created_at, status, item_id, requester_id, owner_id, requester:User(name), item:item_id(name)',\n          )\n          .eq('owner_id', _userId!)\n          .eq('status', 'pending')\n          .order('created_at');\n\n      yield List<Map<String, dynamic>>.from(response);\n      await Future.delayed(Duration(seconds: 5)); // Polling every 5 seconds\n    }\n  }\n\n  Stream<List<Map<String, dynamic>>> streamPendingExchanges() {\n    if (_userId == null) throw Exception('User not logged in');\n\n    return _client\n        .from('requests')\n        .stream(primaryKey: ['id'])\n        .eq('status', 'pending')\n        .map(\n          (requests) =>\n              requests\n                  .where(\n                    (r) =>\n                        r['requester_id'] == _userId ||\n                        r['owner_id'] == _userId,\n                  )\n                  .toList(),\n        );\n  }\n\n  Future<void> confirmExchange(int requestId) async {\n    if (_userId == null) throw Exception('User not logged in');\n\n    final request =\n        await _client\n            .from('requests')\n            .select(\n              'requester_id, owner_id, requester_confirmed, owner_confirmed',\n            )\n            .eq('id', requestId)\n            .maybeSingle();\n\n    if (request == null) throw Exception('Request not found');\n\n    final isRequester = request['requester_id'] == _userId;\n    final updateField = isRequester ? 'requester_confirmed' : 'owner_confirmed';\n\n    await _client\n        .from('requests')\n        .update({updateField: true})\n        .eq('id', requestId);\n\n    final updated =\n        await _client\n            .from('requests')\n            .select('requester_confirmed, owner_confirmed')\n            .eq('id', requestId)\n            .maybeSingle();\n\n    if (updated != null &&\n        updated['requester_confirmed'] == true &&\n        updated['owner_confirmed'] == true) {\n      await _client\n          .from('requests')\n          .update({'status': 'completed'})\n          .eq('id', requestId);\n\n    }\n  }\n\n  \n\n  Future<void> addItem(\n    String name,\n    int quantity,\n    DateTime expDate,\n    int action, // 0 for offer, 1 for trade\n    double latitude, // Updated to accept latitude\n    double longitude, // Updated to accept longitude\n    String description,\n    File imageFile,\n    String? category,\n  ) async {\n    if (_loggedInUsername == null || _userId == null) {\n      throw Exception('User is not logged in');\n    }\n\n    // Upload the image to Supabase Storage\n    final imagePath =\n        'item-images/${DateTime.now().millisecondsSinceEpoch}_${imageFile.path.split('/').last}';\n    final storageResponse = await _client.storage\n        .from('item-images')\n        .upload(imagePath, imageFile);\n\n    if (storageResponse.isEmpty) {\n      throw Exception(\n        'Error uploading image: Upload failed or returned empty response.',\n      );\n    }\n\n    final imageUrl = _client.storage\n        .from('item-images')\n        .getPublicUrl(imagePath);\n\n    try {\n      // Insert the item into the database\n      final response =\n          await _client.from('items').insert({\n            'name': name,\n            'quantity': quantity,\n            'expirationDate': expDate.toIso8601String(),\n            'action': action, // 0 for offer, 1 for trade\n            'latitude': latitude, // Save latitude\n            'longitude': longitude, // Save longitude\n            'description': description,\n            'image': imageUrl, // Save the image URL\n            'user_id': _userId, // Add the user ID\n            'category': category, // Default category\n          }).select();\n\n      print('Insert Response: $response'); // Log the response for debugging\n\n      if (response.isEmpty) {\n        throw Exception('Error adding item: Empty response from Supabase');\n      }\n    } catch (e) {\n      print('Error inserting item: $e'); // Log the error\n      throw Exception(\n        'Error adding item: $e',\n      ); // Re-throw the error with details\n    }\n  }\n\n  // Delete an item from the Supabase database\n  Future<void> deleteItem(int id) async {\n    final response =\n        await _client\n            .from('items')\n            .update({'is_deleted': true})\n            .eq('id', id)\n            .select();\n\n    if (response.isEmpty) {\n      throw Exception('Error deleting item');\n    }\n  }\n\n  // Sign in a user\n  Future<bool> signIn(String username, String password) async {\n    final response =\n        await _client\n            .from('User')\n            .select('id')\n            .eq('username', username)\n            .eq('password', password)\n            .maybeSingle();\n\n    if (response != null && response['id'] != null) {\n      _loggedInUsername = username;\n      _userId = response['id'];\n      print(\n        'Login successful. Username: $_loggedInUsername, User ID: $_userId',\n      );\n      return true;\n    } else {\n      print('Login failed. Invalid username or password.');\n      return false;\n    }\n  }\n\n  // Sign up a new user\n  Future<void> signUp(\n    String name,\n    String username,\n    String email,\n    String password,\n    String location,\n  ) async {\n    final response = await _client.from('User').insert({\n      'username': username,\n      'name': name,\n      'email': email,\n      'password': password,\n      'location': location,\n    });\n  }\n\n  void signOut() {\n    _loggedInUsername = null;\n    _userId = null;\n    print('User signed out');\n  }\n\n  Future<List<Message>> getMessages(int itemId, int receiverId) async {\n    final response = await _client\n        .from('messages')\n        .select()\n        .eq('item_id', itemId)\n        .eq('receiver_id', receiverId)\n        .order('created_at', ascending: true);\n    return (response as List)\n        .map((e) => Message.fromMap(e as Map<String, dynamic>))\n        .toList();\n  }\n\n  Future<void> sendMessage(Message message) async {\n    final response = await _client.from('messages').insert(message.toMap());\n\n    if (response == null || response.isEmpty) {\n      throw Exception('Failed to insert message or response was empty.');\n    }\n  }\n\n  void subscribeToMessages({\n    required int itemId,\n    required Function(Message) onNewMessage,\n  }) {\n    if (_userId == null) return;\n\n    _messageChannel = _client.channel('messages_channel');\n\n    _messageChannel!\n        .onPostgresChanges(\n          event: PostgresChangeEvent.insert,\n          schema: 'public',\n          table: 'messages',\n          callback: (payload) {\n            final data = payload.newRecord;\n            if (data == null) return;\n\n            final message = Message.fromMap(data);\n\n            if (message.itemId == itemId &&\n                (message.senderId == _userId ||\n                    message.receiverId == _userId)) {\n              onNewMessage(message);\n            }\n          },\n        )\n        .subscribe();\n  }\n\n  void unsubscribeFromMessages() {\n    if (_messageChannel != null) {\n      _client.removeChannel(_messageChannel!);\n      _messageChannel = null;\n    }\n  }\n\n  Future<List<ChatPreview>> getUserChats(int currentUserId) async {\n    try {\n      final response = await _client\n          .from('messages')\n          .select('*, users:receiver_id(username)')\n          .or('sender_id.eq.$currentUserId,receiver_id.eq.$currentUserId')\n          .order('created_at', ascending: false);\n\n      Map<int, ChatPreview> chatMap = {};\n\n      for (var item in response) {\n        final int senderId = item['sender_id'];\n        final int receiverId = item['receiver_id'];\n        final int otherUserId = senderId == currentUserId ? receiverId : senderId;\n\n        // Avoid adding duplicate chats\n        if (!chatMap.containsKey(otherUserId)) {\n          chatMap[otherUserId] = ChatPreview(\n            chatId: item['item_id'],\n            userId: otherUserId,\n            username: item['users']['username'],\n            lastMessage: item['content'],\n            lastMessageTime: DateTime.parse(item['created_at']),\n          );\n        }\n      }\n\n      return chatMap.values.toList();\n    } catch (e) {\n      print('Error getting user chats: $e');\n      return [];\n    }\n  }\n\n  String? get currentUsername => _loggedInUsername;\n  int? get currentUserId => _userId;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hand2hand/lib/supabase_service.dart b/hand2hand/lib/supabase_service.dart
--- a/hand2hand/lib/supabase_service.dart	(revision c389a0066a24df29dd6de15c7c6942e5534c1891)
+++ b/hand2hand/lib/supabase_service.dart	(date 1747131018033)
@@ -429,52 +429,44 @@
         .from('messages')
         .select()
         .eq('item_id', itemId)
-        .eq('receiver_id', receiverId)
+        .or(
+        'and(sender_id.eq.$_userId,receiver_id.eq.$receiverId),' +
+            'and(sender_id.eq.$receiverId,receiver_id.eq.$_userId)')
         .order('created_at', ascending: true);
-    return (response as List)
-        .map((e) => Message.fromMap(e as Map<String, dynamic>))
-        .toList();
+
+    final messages = response.map((e) => Message.fromMap(e)).toList();
+    return messages;
   }
 
   Future<void> sendMessage(Message message) async {
-    final response = await _client.from('messages').insert(message.toMap());
-
-    if (response == null || response.isEmpty) {
-      throw Exception('Failed to insert message or response was empty.');
-    }
+    final messageMap = message.toMap();
+    final response = await _client.from('messages').insert(messageMap);
   }
 
-  void subscribeToMessages({
-    required int itemId,
-    required Function(Message) onNewMessage,
-  }) {
-    if (_userId == null) return;
+  void subscribeToMessages({required int itemId, required Function(Message) onNewMessage, }) {
+    if(_userId == null) return;
 
     _messageChannel = _client.channel('messages_channel');
 
-    _messageChannel!
-        .onPostgresChanges(
-          event: PostgresChangeEvent.insert,
-          schema: 'public',
-          table: 'messages',
-          callback: (payload) {
-            final data = payload.newRecord;
-            if (data == null) return;
+    _messageChannel!.onPostgresChanges(
+      event: PostgresChangeEvent.insert,
+      schema: 'public',
+      table: 'messages',
+      callback: (payload) {
+        final data = payload.newRecord;
+        if(data == null) return;
 
-            final message = Message.fromMap(data);
+        final message = Message.fromMap(data);
 
-            if (message.itemId == itemId &&
-                (message.senderId == _userId ||
-                    message.receiverId == _userId)) {
-              onNewMessage(message);
-            }
-          },
-        )
-        .subscribe();
+        if(message.itemId == itemId && (message.senderId == _userId || message.receiverId == _userId)) {
+          onNewMessage(message);
+        }
+      },
+    ).subscribe();
   }
 
   void unsubscribeFromMessages() {
-    if (_messageChannel != null) {
+    if(_messageChannel != null) {
       _client.removeChannel(_messageChannel!);
       _messageChannel = null;
     }
